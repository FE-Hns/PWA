# PWA介绍

## PWA的定义

认识一样事物，要明白的是该事物名字的含义。PWA => Progressive Web Apps 的简称，翻译过来是渐进式网络应用。可以给我们的网页提供一种类似APP的功能，即离线功能，可以带来更加极致的用户体验。它们赋予了开发者可以构建速度更快、富有弹性并且更吸引人的网站的能力，这些网站能够被全球数十亿人访问

## 1.1 PWA的优势所在

虽然我们的移动备变得愈发强大，但我们的移动网络并不是总能满足需求。如果你使用智能手机，你就会知道移动连接是有多么的脆弱。2G、3G 或 4G 这些连接本身都很不错，但是它们时常会失去连接，或者网速变得很差。如果你的业务是跟网络相关的，那这就是你需要去解决的问题。

从历史上来说，原生应用 (下载到手机的) 已经能够提供更好的整体用户体验，你只要下载好原生应用，它便会立即加载。即使没有网络连接，也并非是完全不可用的: 你的设备上已经存储了供用户使用的绝大部分资源。原生应用具备提供有弹性、吸引人的体验的能力，同时也意味它的数量已经呈爆炸式增长。目前在苹果和 Google 的应用商店中，已经有超过400万的原生应用！

从历史上来说，Web 无法提供原生应用所具备的这些强大功能，比如离线能力，瞬时加载和更高的可靠性。这也正是 PWA 成为 Web 颠覆者的契机。主要的浏览器厂商一直在努力改进构建 Web 的方式， 并创建了一组新功能以使 Web 开发者能够创建快速、可靠和吸引人的网站PWA 应该具备以下特点：

* 响应式
* 独立于网络连接
* 类似原生应用的交互体验
* 始终保持更新
* 安全
* 可发现
* 可重连
* 可安装
* 可链接

作为 Web 开发者，这是我们传统构建网站方式的一种转变。这意味着我们可以开始构建可以应对不断变化的网络条件或无网络连接的网站。这还意味着我们可以建立更吸引人的网站来为我们的用户提供一流的浏览体验。

很不错的idea，但是对于那些不支持这些新功能的老浏览器怎么办？ PWA 最棒的一点就是它们真的是“渐进式”的。如果你构建一个 PWA，即使在一个不支持的老旧浏览器上运行，它仍然可以作为一个普通的网站来运行。驱动 PWA 的技术就是这样设计的，只有在支持这些新功能的浏览器中才会增强体验。如果用户的设备支持，那么他们将获得所有额外的好处和更多的改进功能。无论怎样，这对你和你的用户来说都是双赢！

### 1.1.1 PWA基础

说了这么多关于PWA有点，那么还是一头雾水，PWA到底是什么组成的。其实非常简单，PWA是面向web开发者的，所以包含着HTML、CSS 和 JavaScript。

然而， PWA 却更进一步，它为用户提供了增强的体验。

PWA 会指向一个清单 (manifest) 文件，其中包含网站相关的信息，包括图标，背景屏幕，颜色和默认方向。

PWA 使用了叫做 Service Workers 的重要新功能，它可以令你深入网络请求并构建更好的 Web 体验。随着本章的深入，我们将进一步了解它们以及它们带给浏览器的改进。PWA 还允许你将其“添加”到设备的主屏幕上。它会像原生应用那样，通过点击图标便可让你轻松访问一个 Web 应用。

PWA 还可以离线工作。使用 Service Workers，你可以选择性地缓存部分网站以提供离线体验。如果你现在在没有网络连接的情况下浏览网站，由于页面无法连接到服务器，无法下载所需要的各种资源，会提示无网络链接，这种页面的出现会让用户觉得体验极差。

有了 Service Workers，我们的用户无需再面对恐怖的“无网络连接”屏幕了。使用 Service Workers，你可以拦截并缓存任何来自你网站的网络请求。无论你是为移动设备，桌面设备还是平板设备构建网站， 都可以在有网络连接或没有网络连接的情况下控制如何响应请求。举个例子来说，浏览一个商城网站，即使处于离线状态，我们也可以浏览商品，加入购物车等等交互操作，当然下单的操作那肯定得等到网络恢复链接才可以。

## 1.2 PWA核心：Service Workers

正如我之前所提到的，释放 PWA 力量的关键在于 Service Workers 。就其核心来说，Service Workers 只是后台运行的 worker 脚本。它们是用 JavaScript 编写的，只需短短几行代码，它们便可使开发者能够拦截网络请求，处理推送消息并执行许多其他任务。

最棒的一点是，如果用户的浏览器不支持 Service Workers 的话，它们只是简单地回退，你的网站还作为普通的网站。正是由于这一点，它们被描述为“完美的渐进增强”。渐进增强术语是指你可以先创建能在任何地方运行的体验，然后为支持更高级功能的设备增强体验。

### 1.2.1 理解 Service Workers

Service Workers 可以让你全权控制网站发起的每一个请求，这为许多不同的使用场景开辟了可能性。Service Worker 的行为方式也是如此，它可以重定向你的请求，甚至彻底停止。

虽然Service Workers是由JS编写完成，但是与一般的JS文件存在这些许差异。差异主要体现在如下几点

* 运行在它自己的全局脚本上下文中
* 不绑定到具体的网页
* 无法修改网页中的元素，因为它无法访问 DOM
* 只能使用 HTTPS（出于安全原因的考虑）

工作原理图示

[![pic01.png](https://i.loli.net/2018/04/24/5adee305aca48.png)](https://i.loli.net/2018/04/24/5adee305aca48.png)

于是我们得出几点：
1. Service Worker 运行在 worker 上下文中，这意味着它无法访问 DOM，它与应用的主要 JavaScript 运行在不同的线程上，所以它不会被阻塞。
2. 它们被设计成是完全异步的，因此你无法使用诸如同步 XHR 和 localStorage 之类的功能。
3. 在上面的图中，你可以看到 Service Worker 处于不同的线程，并且可以拦截网络请求。可以把它理解为"调度员"，它可以让你全权控制网站中所有进出的网络请求。这种能力使它们极其强大，并允许你来决定如何响应请求

### 1.2.2 Service Worker 的生命周期

Service Worker很像一个应用，在使用之前你需要下载安装注册等等步骤。。

[![生命周期](https://raw.githubusercontent.com/SangKa/PWA-Book-CN/master/assets/figure1.4.png)](https://raw.githubusercontent.com/SangKa/PWA-Book-CN/master/assets/figure1.4.png)


### 1.2.3 基础示例

举一个最简单的例子，来展示，来看看最简单的使用方式。

```html
<html>
  <head>The best web page ever</head>
  <body>
  <script>
    // 注册 service worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js').then(function(registration) {
        // 注册成功
        console.log('ServiceWorker registration successful with scope: ', registration.scope);         
      }).catch(function(err) {
        // 注册失败 :(
        console.log('ServiceWorker registration failed: ', err);
      });
    }
  </script>
  </body>
</html>
```
代码说明：

1. 检查当前浏览器是否支持 Service Workers
2. 如果支持，注册一个叫做 'sw.js' 的 Service Worker 文件
3. 如果成功则打印到控制台
4. 如果发生错误，捕获错误并打印到控制台

在上边的基础之上，我们继续往下进行，如果现在我们有一个需求是这样子的。如果我们请求中含有jpg图片，那么就把它替换成某个图片。

之前我提到过 Service Workers 是事件驱动的，而且 Service Workers 最强大的功能之一就是允许你通过进入 fetch 事件来监听任何网络请求。当一个资源发起 fetch 事件时，你可以决定如何继续进行。你可以将发出的 HTTP 请求或接收的 HTTP 响应更改成任何内容。这相当简单，但同时却非常强大！

```js
self.addEventListener('fetch', function(event) {     
  if (/\.jpg$/.test(event.request.url)) {            
    event.respondWith(fetch('/images/unicorn.jpg')); 
  }
});
```

### 1.2.4 安全考虑

既然Service Worker 可以拦截请求，那么同时这也是非常危险的。比如外部可以通过拦截请求，然后指向危险的代码。所以，出于安全方面的考虑，为了避免这种情况发送，Service Worker 只能在通过 HTTPS 提供服务的网页上注册。这确保了网页在通过网络的过程中没有被篡改。









